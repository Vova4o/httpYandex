// Создание клиента для отправки запросов на сервер
// Добавление HTTP-заголовков
package main

import (
	"fmt"
	"io"
	"net/http"
	"time"
)

// main - клинет для отправки запросов на сервер
func main() {

	// создаем клиента http.Client это структура, которая содержит в себе настройки для отправки запросов
	// в структуре http.Client есть поле Timeout, которое отвечает за время ожидания ответа от сервера
	// устанавливаем время ожидания ответа от сервера в 1 секунду
	client := &http.Client{
		Timeout: 1 * time.Second,
	}

	// NewRequest - функция, которая создает новый запрос
	// создаем запрос с методом GET, адресом http://localhost:8080/time и телом nil
	// в переменную request записываем запрос, а в переменную err ошибку (если она есть)
	// вместо GET можно использовать http.MethodGet, далее по списку адрес сервера и тело запроса
	request, err := http.NewRequest(http.MethodGet, "http://localhost:8080/time", nil)
	// обрабатываем ошибку
	if err != nil {
		fmt.Println("Ошибка формирования запроса:", err)
		return
	}

	// Добавление HTTP-заголовков
	// зачем нужны заголовки? - https://developer.mozilla.org/ru/docs/Web/HTTP/Headers
	// структура http.Request содержит поле Header, которое является картой (map)
	// в карту можно добавлять заголовки с помощью двух методов:
	// 1. Set - устанавливает значение заголовка, если заголовка нет, то он создается
	// 2. Add - добавляет значение заголовка, если заголовка нет, то он создается
	// в качестве ключа используется название заголовка, а в качестве значения - значение заголовка
	// если ипльзовать метод Set, то заголовок будет перезаписан, если использовать метод Add, то заголовок будет добавлен
	// в данном примере мы добавляем заголовок Custom-Header со значением John Doe и 1234
	request.Header.Set("Custom-Header", "John Doe")
	request.Header.Add("Custom-Header", "1234")

	// Do - метод, который отправляет запрос на сервер и получает ответ
	// в переменную response записываем ответ сервера, а в переменную err ошибку (если она есть)
	// вместо Do можно использовать client.Get, client.Post, client.Put, client.Delete
	response, err := client.Do(request)
	// обрабатываем ошибку
	if err != nil {
		fmt.Println("Ошибка отправки запроса:", err)
		return
	}

	// вызов после defer произойдёт при выходе из функции,
	// поэтому Close() с defer можно указать здесь, так как
	// response.Body.Close() нужно вызвать в любом случае
	defer response.Body.Close()
	// читаем тело ответа
	// в переменную body записываем тело ответа, а в переменную err ошибку (если она есть)
	// нас интересует только тело ответа, поэтому из Response мы берем только поле Body
	body, err := io.ReadAll(response.Body)
	// обрабатываем ошибку
	if err != nil {
		fmt.Println("Ошибка чтения ответа:", err)
		return
	}
	// выводим тело ответа в консоль
	fmt.Println(string(body))

	// все что ниже относится к релизу 0.2.4

	// // Чтобы регулярно опрашивать сервер и получать его текущее время, достаточно поместить код с запросом в бесконечный цикл.
	// // Чтобы установить интервал опроса можно использовать функцию time.Sleep().

	// // запускаем бесконечный цикл!
	// for {
	// 	// давайте используем метод Post, чтобы отправить запрос на сервер, для это мы закоментели метод Get

	// 	// Post - метод, который отправляет POST запрос на сервер
	// 	// метод Post возвращает два значения: ответ сервера и ошибку (если она есть)
	// 	// метод Post принимает три параметра:
	// 	// 1. url - адрес сервера, на который отправляется запрос
	// 	// 2. https://www.geeksforgeeks.org/http-headers-content-type/ - про Content-Type все возможные виды типа запросов
	// 	// 3. тело запроса, в нашем случае тело запроса пустое, поэтому nil
	// 	// body — переменная интерфейсного типа io.Reader, из которой будут прочитаны передаваемые данные.
	// 	response, err := http.Post("http://localhost:8080", "text/plain", nil)

	// 	// // Get - метод, который отправляет GET запрос на сервер
	// 	// // метод Get возвращает два значения: ответ сервера и ошибку (если она есть)
	// 	// // приравниваем ответ сервера к переменной response, а ошибку к err
	// 	// response, err := http.Get("http://localhost:8080/time")
	// 	// // если ошибка не пустая, то выводим ее в консоль и завершаем программу
	// 	// if err != nil {
	// 	// 	fmt.Println(err)
	// 	// 	return
	// 	// }

	// 	// ReadAll - метод, который читает все данные из ответа сервера
	// 	// Чтобы не читать ответ кусками, можно воспользоваться функцией io.ReadAll(r Reader) ([]byte, error).
	// 	// Она прочитает сразу все данные и возвратит полученный слайс байт.
	// 	// слайс байт приравниваем к переменной body, а ошибку к err
	// 	body, err := io.ReadAll(response.Body)

	// 	// Стоить заметить, что если вызов http.Get() прошёл успешно,
	// 	// то метод Close() вызывается обязательно, независимо от того, прочитаете вы тело ответа или нет.
	// 	response.Body.Close()

	// 	// если ошибка не пустая, то выводим ее в консоль и завершаем программу
	// 	if err != nil {
	// 		fmt.Println("Ошибка чтения:", err)
	// 		return
	// 	}

	// 	// выводим ответ сервера в консоль в виде строки
	// 	// напоминаю что body это слайс байт, поэтому приводим его к строке
	// 	fmt.Println("Ответ сервера:", string(body))

	// 	// добавляем код статуса ответа сервера
	// 	// В случае если сервер запущен, то вывод будет таким - Статус ответа: 200
	// 	// fmt.Println("Статус ответа:", response.Status)

	// 	// добавляем задержку в 5 секунд
	// 	// цикл будет выполняться каждые 5 секунд
	// 	time.Sleep(5 * time.Second)

	// }

	// // если ошибки нет, то выводим ответ сервера в консоль
	// // закоментил респонс чтобы не засорять вывод в консоль
	// // fmt.Println(response)

}
